# Fragments: 開発者向けナレッジサマリー（技術仕様書）

本ドキュメントは、「Fragments」プロジェクトのアーキテクチャ設計、技術選定の意図、および将来の開発指針をまとめたものです。
プロジェクトに参加する全ての開発者は、コードを変更する前に本ドキュメントを熟読し、設計思想（Philosophy）を理解することが求められます。

---

## 1. アーキテクチャの階層構造と責務の分離

このプロジェクトでは、関心の分離（Seperation of Concerns）を徹底するため、明確なレイヤー構造を採用しています。これにより、各コンポーネントが単一の責任を持ち、テスト容易性と保守性が向上しています。

### 各レイヤーの役割と設計意図

*   **Routers (`backend/routers/`)**:
    *   **役割**: HTTPリクエストの受付、レスポンスの返却、認証ガード（`@login_required`）の適用のみを担当します。ビジネスロジックは一切持ちません。
    *   **こだわり**: ルーターは「司令塔」に徹し、実際の処理は Service 層へ委譲します。これにより、APIのエンドポイント設計が変わっても、ビジネスロジックへの影響を最小限に抑えられます。

*   **Services (`backend/services/`)**:
    *   **役割**: アプリケーションのビジネスロジック、トランザクション管理、例外処理のオーケストレーションを担当します。
    *   **こだわり**: データベース操作（CRUD）はここで完結させます。複数のモデルにまたがる操作（例: ユーザー登録時の初期設定作成）もここで一元管理し、整合性を保ちます。

*   **Schemas (`backend/schemas/`)**:
    *   **役割**: データの入出力定義、バリデーション、シリアライズ/デシリアライズを担当します（Marshmallowを使用）。
    *   **こだわり**: APIのインターフェース契約（Contract）として機能します。入力データの型変換や、不要なフィールドの除外（`dump_only`, `load_only`）をここで行い、不正なデータが Service 層に流入するのを防ぎます。

*   **Models (`backend/models/`)**:
    *   **役割**: データベースのスキーマ定義と、データそのものに付随するロジック（例: パスワードハッシュ化メソッド）を担当します。
    *   **こだわり**: SQLAlchemy の `db.Model` を継承しますが、ビジネスロジックは Service 層に譲り、ここでは「データの表現」に集中します。

*   **Extensions (`backend/extensions.py`)**:
    *   **役割**: `db`, `migrate`, `login_manager` などの Flask 拡張インスタンスを一箇所で生成します。
    *   **こだわり**: これらを `app.py` ではなく独立したモジュールにすることで、`app.py` と `models` の双方が `extensions` をインポート可能になり、**Flask アプリケーションによくある「循環参照（Circular Import）」問題を根本から回避**しています。

### 循環参照の回避（Flask特有のパターン）

Flask で大規模なアプリケーションを構築する際、最も陥りやすい罠が循環参照です。
本プロジェクトでは、以下の戦略でこれを防いでいます：

1.  **Extensions パターン**: 前述の通り、拡張インスタンスを独立ファイル化。
2.  **Delayed Import（遅延インポート）**: `app.py` 内での Blueprint の登録時や、`user_loader` 内でのモデル参照時に、関数の内部で `import` を行うことで、モジュールロード時の相互依存を断ち切っています。

---

## 2. 堅牢なデータ整合性とセキュリティ

「データは資産である」という考えのもと、セキュリティと整合性はフレームワークの機能を最大限活用して担保しています。

### 入力バリデーションとサニタイゼーション
Marshmallow の機能を駆使し、防御的プログラミングを実践しています。

*   **バリデーション**: `UserSchema` などで `validate.Length` や `fields.Email` を使用し、形式的なチェックを Schema 層で強制しています。
*   **サニタイゼーション**: `@pre_load` デコレータを使用し、データがバリデーションされる**前**に `strip()` 等のクリーニング処理を自動実行しています。これにより、「空白のみのユーザー名」などのエッジケースを排除しています。

### パスワードハッシュ化のカプセル化
セキュリティにおいて「実装の分散」は事故の元です。
`User` モデル内に `set_password` と `check_password` メソッドを実装し、ハッシュ化ロジック（Werkzeug の `generate_password_hash`）をモデル内に完全に隠蔽（カプセル化）しています。Service 層ですら「ハッシュ化のアルゴリズム」を意識する必要はありません。

### トランザクション管理による Atomicity
`backend/services/user_service.py` の `register_user` メソッドに見られるように、処理は以下のフローで統一されています：

1.  `db.session.add(obj)`
2.  `db.session.flush()`（ID確定のため）
3.  関連データの作成
4.  `db.session.commit()`（確定）
5.  エラー時は `db.session.rollback()`

これにより、例えば「ユーザーは作成されたが初期設定の作成に失敗した」といった中途半端なデータ（不整合）がデータベースに残ることを防いでいます（Atomicityの保証）。

---

## 3. テスト戦略とインメモリ環境

品質担保のため、pytest を用いた高速かつ再現性の高いテスト環境を整備しています。

### `conftest.py` の設計思想
テストコードのボイラープレートを排除するため、`conftest.py` に共用 Fixture を集約しています。

*   **InMemory Database (`sqlite:///:memory:`)**:
    *   **理由**: ディスクI/Oが発生しないため、テスト実行が極めて高速です。また、実行ごとに完全にクリーンな状態から始まるため、前のテストの副作用（State Leakage）を確実に防げます。
*   **Fixture Scopes**:
    *   `app` (scope="session"): アプリケーション自体の起動コストは高いため、テストセッション全体で1回のみ行います。
    *   `db` (scope="function"): テストケースごとにテーブルの `create_all()` / `drop_all()` を行い、常に「新品のDB」を提供します。これにより、テスト間の依存関係を排除しています。

---

## 4. 運用を見据えた標準化

長期的な運用に耐えうるよう、各所に標準化のルールを敷いています。

*   **RESTful API 原則**:
    *   **リソース指向**: `/users`, `/posts` のような名詞ベースのエンドポイント。
    *   **HTTPメソッドの適切な使用**: 作成は `POST (201 Created)`, 取得は `GET (200 OK)`, 削除は `DELETE (200 OK or 204 No Content)` を厳格に守っています。
*   **ログとエラーハンドリング**:
    *   `app.py` で `DomainError` などのカスタム例外を一元的にキャッチし、JSON形式で標準化されたエラーレスポンスを返却しています。これにより、フロントエンドはエラーハンドリングを統一的に実装できます。
*   **Alembic によるマイグレーション**:
    *   DBスキーマの変更は全てコード（Migration Script）として管理されています。「手動でSQLを流す」運用は禁止されており、これにより開発環境と本番環境のDB構造が常に一致することが保証されます。

---

## 5. 将来の拡張性と技術的負債への備え

プロジェクトの成長に伴い、以下の点に注意が必要です。

*   **Service 層の分割**:
    *   現在は `user_service.py`, `post_service.py` と分かれていますが、機能が増大した場合、各ファイルをさらに細かいドメイン（例: `auth_service`, `profile_service`）に分割することを躊躇しないでください。
*   **N+1問題への対策**:
    *   現在、`PostSchema` は `user_id` のみを返していますが、将来的に「投稿リストと共にユーザー情報も返したい」となった場合、安易に Schema で `Nested` を使うと N+1 問題が発生します。
    *   **対策**: Service 層でのクエリ時に `db.session.query(Post).options(joinedload(Post.user))` のように Eager Loading を明示的に使用し、1回のクエリでデータを取得するようにしてください。
*   **技術的負債**:
    *   現在、認証トークンは Flask-Login のセッション管理（Cookie）に依存しています。将来的に完全なモバイルアプリ化（SPA完全分離）を進める場合、JWT（JSON Web Token）ベースの認証への移行が必要になる可能性があります。

---

## 6. Docker戦略と CI/CD パイプラインの最適化

「いつでも、誰でも、同じ環境で」開発・テストができる環境をコンテナ技術で実現しています。

### 環境分離の意図
*   **`Dockerfile` vs `Dockerfile.test`**:
    *   本番/開発用 (`Dockerfile`) は軽量化を目指していますが、テスト用 (`Dockerfile.test`) には開発ツールやテストランナーが含まれています。
    *   あえてファイルを分けることで、CI環境では余計なビルドステップを省きつつ、必要なツールだけが含まれた最適化されたイメージを使用できます。

### GitHub Actions による自動化 (`.github/workflows/test.yml`)
*   **Push Trigger**: `backend/` 配下のコードが変更された時のみ自動で走ります。
*   **フロー**:
    1.  `Dockerfile.test` をビルド。
    2.  コンテナ内で `pytest` を実行。
*   **「最速」へのこだわり**: データベースをコンテナ内に立てるのではなく、SQLite (InMemory) を採用しているため、Dockerコンテナが立ち上がってからテスト完了までの時間が圧倒的に短くなっています。これにより、開発者はPull Requestを出してから数分以内に結果を知ることができます。

---

## 開発者へのメッセージ

Fragments のコードベースは、単に動くことだけを目指したものではありません。「読みやすく、直しやすく、壊れにくい」ことを目指して設計されています。

新しい機能を追加する際は、既存のパズル（Fragments）のピースがどのように美しく噛み合っているかを観察してください。「なぜここはこう書かれているのか？」と疑問に思った時、答えは必ずこの設計思想の中にあります。
